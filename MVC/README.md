# 《MVC》
## 什么是MVC
一种设计模式，所有的页面都可以分为：
* M：models，数据层
```javascript
Model层
Model = {
    data: { 需要用到的数据 }，
    create(): { 增数据 },
    delete(): { 删数据 },
    update() {更新数据},
    get():{ 获取数据 } 
}
```
* V：views，视图层
```javascript
View层
View = {
    el:null,
    html: `......` //视图模板
    init(){初始化页面},
    render(){ 刷新页面 }
}
```
* C：controller：控制层
```javascript
Controller = {
   init(){},
   events:{ }，
   method() {}，
}
```
* 三者间的联系每个程序员都有不同的理解，没有完全确定的结论
* 
## EventBus
在代码中EventBus就像一个上帝，可以把所有的事件触发都交给他，同时它还可以在任何地方来指定时间的触发。这可以使两个本没有关联的元素或者组件有了通信的能力。主要使用三个API：
* `eventbus.on()` 开启监听事件
* `eventbus.trigger()` 触发事件
* `eventbus.off()` 关闭监听事件

## 表驱动编程
* 当有大量的类似但是不重复的代码时
* 观察发现其中哪些才是重要的数据
* 把重要的数据做成哈希表，这就是数据结构的好处

最大的好处就是将数据和逻辑区分开来，逻辑代码一旦写好，数据无论是增加还是删除都不会影响功能的实现，除非修改数据的结构。同时数据的来源也可以灵活多变，可以从数据库，文件，代码中引用。最后也可以方便的重构功能，只要有数据随时可以重新写出另外的功能。
## 我是怎样理解模块化的
模块化开发其实就是封装细节，提供使用接口，彼此之间互不影响，每个模块都是实现某一特定的功能。大到一个文件，小到甚至一个函数也可以使用模块化的思想理解，函数返回一个值，外部引用该函数得到值而不知道也不关心函数内部的处理。因此从写一个函数开始我们就已经在使用模块化的思想了，而目前的学习也不过是将这个思想应用到更大的平台上而已。
## 抽象思维
### 最小知识原则
* 引入一个模块需要引用html，css，js
* 引入一个模块需要引用html，js
* 引入一个模块需要引用js
#### 缺点
网速慢时页面是空白的，没有内容和样式。可以使用菊花图，骨架图等等解决。
### 以不变应万变
* 每个模块都可以用m+v+c搞定
* 那么每个模块都可以这样写
* 不用再考虑类似的需求怎么做了
#### 缺点
* 有时候会有一些多余的用不到的代码
* 有时候有特殊情况不知道怎么变动，比如没有html的模块怎么做MVC
### view = render(data)
* 比起直接操作DOM，直接将数据render出来要简单
* 只改变data就可以得到对应的view
#### 缺点
* render的渲染一定会比操作DOM消耗性能，
* 可以用虚拟DOM解决该问题，它会使render只改变需要改变的地方

## 解耦
一个项目有很多模块，都在依赖jq，这时新创建一个层依赖jq，底层模块再去依赖它，这就叫中间层。

JS代码不能以括号开头



